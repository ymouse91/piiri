<!doctype html>
<html lang="fi">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<meta name="theme-color" content="#0b1220" />
<link rel="manifest" href="manifest-iphone.webmanifest">
<link rel="icon" sizes="192x192" href="./icon192.png">
<link rel="apple-touch-icon" sizes="192x192" href="./icon192.png">
<meta property="og:image" content="https://ymouse91.github.io/piiri/icon192.png"/>
<title>IQ Circuit â€“ iPhone</title>

<style>
/* =====================================================
   IQ Circuit â€“ iPhone only (portrait)
   - Board top, pieces always visible bottom (2 Ã— 5)
   - App bar: puzzle select + next + reset
   - Fixed piece cards: no jumping on rotation
===================================================== */
*{ box-sizing:border-box; }
html,body{ margin:0; padding:0; height:100%; overflow:hidden; }
body{
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  background:#0b1220;
  color:#e7eef8;
}

:root{
  --bg:#0b0f14;
  --text:#e7eef8;
  --muted:#a9b7c7;
  --line:rgba(255,255,255,.14);

  --wire: rgba(255, 235, 120, .95);
  --wire2: rgba(255, 235, 120, .55);
  --dot: rgba(255, 235, 120, .98);

  --cell: min(10.5vw, 52px);
  --gap: 6px;
}

/* Top bar */
.topbar{
  padding: calc(env(safe-area-inset-top) + 8px) 10px 8px;
  border-bottom:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.14);
}
.topbar .row1{
  display:flex; align-items:baseline; justify-content:space-between;
  gap:10px;
}
.topbar h1{
  margin:0;
  font-size:15px;
  font-weight:800;
  letter-spacing:.2px;
}
#statusLine{
  font-size:13px;
  font-weight:700;
  color:var(--muted);
  text-align:right;
  max-width: 60%;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
.topbar .row2{
  display:flex;
  gap:8px;
  margin-top:6px;
}
#puzzleSelect{
  flex:1;
  min-width:0;
  height:34px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.14);
  background: rgba(0,0,0,.22);
  color: var(--text);
  font-weight:800;
  padding: 6px 10px;
}
#puzzleSelect option{ background:#1b2238; color:#e9eefc; }
button{
  appearance:none;
  height:34px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.06);
  color: var(--text);
  font-weight:900;
  padding: 0 12px;
}
button:active{ transform: translateY(1px); }

/* App layout */
.app{
  height: calc(100dvh - 86px);
  display:flex;
  flex-direction:column;
  gap:10px;
  padding:10px;
  padding-bottom: calc(10px + env(safe-area-inset-bottom));
}

/* Board */
.boardStage{
  flex:1;
  min-height:0;
  display:flex;
  align-items:center;
  justify-content:center;
}
.board{
  display:grid;
  grid-template-columns: repeat(8, var(--cell));
  grid-template-rows: repeat(4, var(--cell));
  gap: var(--gap);
  padding:10px;
  border-radius: 16px;
  background: rgba(0,0,0,.22);
  border:1px solid rgba(255,255,255,.14);
  user-select:none;
  touch-action: manipulation;
}
.sq{
  width:var(--cell);
  height:var(--cell);
  border-radius: 12px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.04);
  position:relative;
  overflow:hidden;
}
.sq.occ{
  background: rgba(123,212,255,.12);
  border-color: rgba(123,212,255,.34);
}
.sq .pid{
  position:absolute;
  top:4px; left:4px;
  font-weight:900;
  font-size:10px;
  opacity:.85;
  text-shadow: 0 1px 0 rgba(0,0,0,.35);
  pointer-events:none;
}
.sq .svg{ position:absolute; inset:0; pointer-events:none; }

/* Pieces grid: 2 Ã— 5 fixed */
.piecesStage{
  height: 360px;
  min-height: 360px;
}
#piecesGrid{
  height:100%;
  display:grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: repeat(5, 1fr);
  gap:10px;
}
.pieceCard{
  border-radius: 14px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.18);
  display:flex;
  flex-direction:column;
  overflow:hidden;
  min-height:0;
}
.pieceCard.used{ opacity:.45; filter: grayscale(.2); }
.pieceCard.selected{
  outline:2px solid rgba(123,212,255,.55);
  outline-offset:-2px;
  border-color: rgba(123,212,255,.55);
  background: rgba(123,212,255,.10);
}
.pieceTop{ display:none; }



/* ---- piece variants: show all sides at once (horizontal) ---- */
.thumbGrid{
  flex:1;
  min-height:0;
  display:grid;
  grid-template-rows: 1fr;
  gap:8px;
  padding:10px;
}
.thumbItem{
  min-height:0;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.04);
  display:flex;
  align-items:center;
  justify-content:center;
  overflow:hidden;
}
.thumbItem.sel{
  outline:2px solid rgba(123,212,255,.55);
  outline-offset:-2px;
  border-color: rgba(123,212,255,.45);
  background: rgba(123,212,255,.10);
}
.thumbSvg{
  width:100%;
  height:100%;
  max-width: 170px;
  max-height: 170px;
}
.thumbSvg svg{ width:100%; height:100%; display:block; }

.pLabel{
  position:absolute;
  left:8px;
  top:6px;
  font-size:10px;
  font-weight:900;
  color: rgba(231,238,248,.92);
  opacity:.92;
  pointer-events:none;
  text-shadow: 0 1px 0 rgba(0,0,0,.35);
}

/* status blink on solve */
@keyframes solvedBlink { 0%{opacity:1} 50%{opacity:.25} 100%{opacity:1} }
#statusLine.solved{ animation: solvedBlink .6s ease-in-out 4; font-weight:900; color:#e7eef8; }
</style>
</head>

<body>
<header class="topbar">
  <div class="row1">
    <h1>IQ Circuit</h1>
    <div id="statusLine">Ladataan pulmiaâ€¦</div>
  </div>
  <div class="row2">
    <select id="puzzleSelect"></select>
    <button id="nextBtn">Next</button>
    <button id="resetBtn">Reset</button>
  </div>
</header>

<main class="app">
  <section class="boardStage">
    <div class="board" id="board"></div>
  </section>

  <section class="piecesStage">
    <div id="piecesGrid"></div>
  </section>
</main>

<script>
/*** Directions bitmask ***/
const N=1, E=2, S=4, W=8;

/*** Shapes ***/
const SHAPES = {
  I2: ["x","x"],
  I3: ["x","x","x"],
  O2: ["xx","xx"],
  L2: ["xx","x-"],
  L3: ["xx","x-","x-"],
  T3: ["-x-","xxx"],
  Z3: ["xx-","-xx"],
};

/*** Piece library (as in your original) ***/
const PIECES = {
  1: { shape: SHAPES.I2, sides: [
    { wires: {"0,0": S, "0,1": N|S}, dots:["0,0"] },                          // A
    { wires: {"0,0": 0, "0,1": W|E}, dots:[] }                                // B
  ]},
  2: { shape: SHAPES.I2, sides: [
    { wires: {"0,0": S|E, "0,1": N}, dots:["0,1"] },                           // A
    { wires: {"0,0": N|S, "0,1": N|S}, dots:[] }                               // B
  ]},
  3: { shape: SHAPES.I3, sides: [
    { wires: {"0,0": S, "0,1": N|S, "0,2": N|S}, dots:["0,0"] },               // A
    { wires: {"0,0": W|S, "0,1": N|S, "0,2": N|S}, dots:[] }                   // B
  ]},
  4: { shape: SHAPES.I3, sides: [
    { wires: {"0,0": 0, "0,1": S, "0,2": N|E}, dots:["0,1"] },                 // A
    { wires: {"0,0": 0, "0,1": W|S, "0,2": N|S}, dots:[] }                     // B
  ]},
  5: { shape: SHAPES.O2, sides: [
    { wires: {"0,0": W|S, "0,1": N|E, "1,1": W|N, "1,0": S|N}, dots:[] },      // A
    { wires: {"0,0": N|E, "1,0": W|E, "0,1": E, "1,1": W|E}, dots:["0,1"] }    // B
  ]},
  6: { shape: SHAPES.L2, sides: [
    { wires: {"0,1": S|N, "0,0": S|E, "1,0": W|E}, dots:[] },                  // A
    { wires: {"0,1": S|N, "0,0": S|E, "1,0": W}, dots:["1,0"] }                // B
  ]},
  7: { shape: SHAPES.L2, sides: [
    { wires: {"0,1": S|N, "0,0": S|E, "1,0": W|S}, dots:[] },                  // A
    { wires: {"0,1": S|N, "0,0": S|N, "1,0": S}, dots:["1,0"] }                // B
  ]},
  8: { shape: SHAPES.L3, sides: [
    { wires: {"1,0": W|E, "0,0": E|S, "0,1": N|S, "0,2": N|E}, dots:[] },      // A
    { shape: ["xx","-x","-x"], wires: {"0,0": S|E, "1,0": W|S, "1,1": N|S, "1,2": N|E}, dots:[] } // B
  ]},
  9: { shape: SHAPES.T3, sides: [
    { wires: {"1,0": S|N, "0,1": N|E, "1,1": W|N, "2,1": 0}, dots:[] },        // A
    { wires: {"1,0": N|E, "0,1": N|E, "1,1": W|E, "2,1": W|E}, dots:[] }       // B
  ]},
  10:{ shape: SHAPES.Z3, sides: [
    { shape: ["xx-","-xx"], wires: {"0,0": S|E, "1,0": W|E, "1,1": 0, "2,1": 0}, dots:[] }, // A
    { shape: ["-xx","xx-"], wires: {"1,1": N|S, "1,0": S|E, "2,0": W, "0,1": 0}, dots:["2,0"] } // B
  ]},
};

/*** Helpers: parse shape -> cells list ***/
function cellsFromShape(shape){
  const cells = [];
  const h = shape.length;
  const w = Math.max(...shape.map(r => r.length));
  for(let y=0;y<h;y++){
    const row = shape[y];
    for(let x=0;x<w;x++){
      const ch = row[x] || "-";
      if(ch === "x") cells.push([x,y]);
    }
  }
  return { w, h, cells };
}

/*** Rotate (CW) a point within bounding box wÃ—h ***/
function rotPointCW(x,y,w,h,rot){
  if(rot===0) return [x,y,w,h];
  if(rot===90) return [h-1-y, x, h, w];
  if(rot===180) return [w-1-x, h-1-y, w, h];
  return [y, w-1-x, h, w];
}

/*** Rotate direction mask CW by rot ***/
function rotMaskCW(mask, rot){
  rot = ((rot%360)+360)%360;
  if(rot===0) return mask;
  const steps = rot/90;
  let m = mask;
  for(let i=0;i<steps;i++){
    let nm = 0;
    if(m & N) nm |= E;
    if(m & E) nm |= S;
    if(m & S) nm |= W;
    if(m & W) nm |= N;
    m = nm;
  }
  return m;
}

/*** Get side data for piece: shape (possibly overridden) + wires/dots ***/
function getSideData(pid, sideMode){
  const p = PIECES[pid];
  if(!p) throw new Error("Piece missing: "+pid);

  if(sideMode === "blank"){
    const sh = p.shape;
    const base = cellsFromShape(sh);
    return { shape: sh, w: base.w, h: base.h, cells: base.cells, wires: {}, dots: [] };
  }

  const sideIndex = (sideMode==="A") ? 0 : 1;
  const side = p.sides[sideIndex];
  const sh = side.shape || p.shape;
  const base = cellsFromShape(sh);
  return { shape: sh, w: base.w, h: base.h, cells: base.cells, wires: side.wires || {}, dots: side.dots || [] };
}

/*** Rotate side data to produce rotated cells + rotated wires/dots in rotated local coords ***/
function getRotatedSide(pid, sideMode, rot){
  const sd = getSideData(pid, sideMode);
  const w0 = sd.w, h0 = sd.h;

  let rotW = w0, rotH = h0;

  const cells = sd.cells.map(([x,y])=>{
    const [rx,ry,nw,nh] = rotPointCW(x,y,w0,h0,rot);
    rotW = nw; rotH = nh;
    return [rx,ry];
  });

  const wires = {};
  for(const key of Object.keys(sd.wires)){
    const [xStr,yStr] = key.split(",");
    const x = parseInt(xStr,10), y = parseInt(yStr,10);
    const [rx,ry,nw,nh] = rotPointCW(x,y,w0,h0,rot);
    rotW = nw; rotH = nh;
    const m = rotMaskCW(sd.wires[key]||0, rot);
    wires[rx+","+ry] = m;
  }

  const dots = sd.dots.map(k=>{
    const [xStr,yStr] = k.split(",");
    const x = parseInt(xStr,10), y = parseInt(yStr,10);
    const [rx,ry,nw,nh] = rotPointCW(x,y,w0,h0,rot);
    rotW = nw; rotH = nh;
    return rx+","+ry;
  });

  return { w: rotW, h: rotH, cells, wires, dots };
}

/*** Board state ***/
const ROWS=4, COLS=8;
const boardEl = document.getElementById("board");
const trayEl = document.getElementById("piecesGrid");
const statusEl = document.getElementById("statusLine");

let selectedPid = 1;
let placements = new Map(); // pid -> {pid, sideMode, rot, r0, c0}
let lockedPids = new Set(); // Master givens (ei saa poistaa)

/*** Game puzzles + goal layers ***/
let gamePuzzles = [];
let currentPuzzleIndex = -1;
let currentPuzzle = null;
let goalMask = null;
let goalDot = null;
let showGoal = false;
let wizardGoalDot = null; // boolean[ROWS][COLS] or null

let pieceUI = {};
for(let pid=1; pid<=10; pid++) pieceUI[pid] = { sideMode: "A", rot: 0 };

function blankAllowed(pid){ return pid>=1 && pid<=4; }

function setStatus(msg){
  statusEl.textContent = msg;
}
function setSolvedStatus(msg){
  statusEl.textContent = msg;
  statusEl.classList.remove("solved");
  void statusEl.offsetWidth;
  statusEl.classList.add("solved");
}

/*** Build board squares ***/
const sqEls = [];
function buildBoard(){
  boardEl.innerHTML = "";
  sqEls.length = 0;
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const d = document.createElement("div");
      d.className = "sq";
      d.dataset.r = r;
      d.dataset.c = c;
      d.addEventListener("click", onBoardClick);
      boardEl.appendChild(d);
      sqEls.push(d);
    }
  }
}

/*** SVG in a square based on mask + dot ***/
function wireSvg(mask, hasDot, opacity=1){
  const stroke = getComputedStyle(document.documentElement).getPropertyValue('--wire').trim() || "rgba(255,235,120,.95)";
  const stroke2 = getComputedStyle(document.documentElement).getPropertyValue('--wire2').trim() || "rgba(255,235,120,.55)";
  const dotCol = getComputedStyle(document.documentElement).getPropertyValue('--dot').trim() || "rgba(255,235,120,.98)";
  const cx=50, cy=50;
  const pts = { N:[50,12], E:[88,50], S:[50,88], W:[12,50] };
  const segs = [];
  if(mask & N) segs.push(`M ${cx} ${cy} L ${pts.N[0]} ${pts.N[1]}`);
  if(mask & E) segs.push(`M ${cx} ${cy} L ${pts.E[0]} ${pts.E[1]}`);
  if(mask & S) segs.push(`M ${cx} ${cy} L ${pts.S[0]} ${pts.S[1]}`);
  if(mask & W) segs.push(`M ${cx} ${cy} L ${pts.W[0]} ${pts.W[1]}`);

  const pathMain = segs.length ? `<path d="${segs.join(" ")}" stroke="${stroke}" stroke-width="10" stroke-linecap="round" fill="none"/>` : "";
  const pathGlow = segs.length ? `<path d="${segs.join(" ")}" stroke="${stroke2}" stroke-width="16" stroke-linecap="round" fill="none" opacity=".55"/>` : "";
  const dot = hasDot ? `<circle cx="${cx}" cy="${cy}" r="10" fill="${dotCol}"/>` : "";
  const dotRing = hasDot ? `<circle cx="${cx}" cy="${cy}" r="14" fill="none" stroke="${stroke2}" stroke-width="5" opacity=".55"/>` : "";

  return `<svg class="svg" viewBox="0 0 100 100" aria-hidden="true" style="opacity:${opacity};">${pathGlow}${pathMain}${dotRing}${dot}</svg>`;
}

/*** Compute per-cell occupancy + mask/dot from placements ***/
function computeBoardLayers(){
  const occ = Array.from({length: ROWS}, ()=>Array(COLS).fill(null));
  const mask = Array.from({length: ROWS}, ()=>Array(COLS).fill(0));
  const pieceDot  = Array.from({length: ROWS}, ()=>Array(COLS).fill(false));

  for(const [pid, pl] of placements){
    const rs = getRotatedSide(pid, pl.sideMode, pl.rot);
    const dotSet = new Set(rs.dots);

    for(const [x,y] of rs.cells){
      const br = pl.r0 + y;
      const bc = pl.c0 + x;
      if(br<0||bc<0||br>=ROWS||bc>=COLS) continue;

      occ[br][bc] = pid;

      const k = x+","+y;
      mask[br][bc] = rs.wires[k] || 0;
      pieceDot[br][bc] = dotSet.has(k);
    }
  }

  const goalDotLayer = wizardGoalDot;
  const dotRender = Array.from({length: ROWS}, (_,r)=>Array.from({length: COLS}, (_,c)=>{
    const a = !!pieceDot[r][c];
    const b = goalDotLayer ? !!goalDotLayer[r][c] : false;
    return a || b;
  }));
  const dotCheck = goalDotLayer ? goalDotLayer : pieceDot;

  return {occ, mask, pieceDot, goalDot: goalDotLayer, dotRender, dotCheck};
}

/*** Render board ***/
function renderBoard(){
  const {occ, mask, dotRender} = computeBoardLayers();
  for(const el of sqEls){
    const r = parseInt(el.dataset.r,10);
    const c = parseInt(el.dataset.c,10);

    const pid = occ[r][c];
    el.classList.toggle("occ", !!pid);

    const m = mask[r][c] || 0;
    const hasDot = !!dotRender[r][c];

    el.innerHTML = "";
    if(pid){
      const tag = document.createElement("div");
      tag.className = "pid";
      tag.textContent = pid;
      el.appendChild(tag);

      if(lockedPids.has(pid)){
        const lk = document.createElement("div");
        lk.textContent = "ðŸ”’";
        lk.style.position = "absolute";
        lk.style.right = "3px";
        lk.style.top = "2px";
        lk.style.fontSize = "8px";
        lk.style.opacity = ".95";
        lk.style.pointerEvents = "none";
        el.appendChild(lk);
      }
    }
    if(showGoal && goalMask && goalDot){
      el.insertAdjacentHTML("beforeend", wireSvg(goalMask[r][c]||0, !!goalDot[r][c], 0.22));
    }
    el.insertAdjacentHTML("beforeend", wireSvg(m, hasDot, 1));
  }
}

/*** Mini preview (SVG) for a piece side/rot ***/
function renderThumbSvg(pid, sideMode, rot){
  const rs = getRotatedSide(pid, sideMode, rot);

  const cell = 26;
  const pad = 8;
  const wPx = rs.w*cell + pad*2;
  const hPx = rs.h*cell + pad*2;

  const dotSet = new Set(rs.dots);

  let rects = "";
  for(const [x,y] of rs.cells){
    const rx = pad + x*cell;
    const ry = pad + y*cell;
    rects += `<rect x="${rx}" y="${ry}" width="${cell-2}" height="${cell-2}" rx="7"
      fill="rgba(123,212,255,.14)" stroke="rgba(123,212,255,.30)" stroke-width="1"/>`;
  }

  const stroke = "rgba(255,235,120,.95)";
  const stroke2 = "rgba(255,235,120,.55)";

  let wires = "";
  for(const [x,y] of rs.cells){
    const key = x+","+y;
    const m = rs.wires[key] || 0;
    const hasDot = dotSet.has(key);
    if(!m && !hasDot) continue;

    const x0 = pad + x*cell;
    const y0 = pad + y*cell;
    const cx = x0 + (cell-2)/2;
    const cy = y0 + (cell-2)/2;

    const edge = { N:[cx, y0+3], E:[x0+cell-5, cy], S:[cx, y0+cell-5], W:[x0+3, cy] };

    const segs = [];
    if(m & N) segs.push(`M ${cx} ${cy} L ${edge.N[0]} ${edge.N[1]}`);
    if(m & E) segs.push(`M ${cx} ${cy} L ${edge.E[0]} ${edge.E[1]}`);
    if(m & S) segs.push(`M ${cx} ${cy} L ${edge.S[0]} ${edge.S[1]}`);
    if(m & W) segs.push(`M ${cx} ${cy} L ${edge.W[0]} ${edge.W[1]}`);

    if(segs.length){
      wires += `<path d="${segs.join(" ")}" stroke="${stroke2}" stroke-width="8" stroke-linecap="round" fill="none" opacity=".55"/>`;
      wires += `<path d="${segs.join(" ")}" stroke="${stroke}" stroke-width="5" stroke-linecap="round" fill="none"/>`;
    }

    if(hasDot){
      wires += `<circle cx="${cx}" cy="${cy}" r="6" fill="${stroke}"/>`;
      wires += `<circle cx="${cx}" cy="${cy}" r="9" fill="none" stroke="${stroke2}" stroke-width="4" opacity=".55"/>`;
    }
  }

  return `<svg viewBox="0 0 ${wPx} ${hPx}" aria-hidden="true" preserveAspectRatio="xMidYMid meet">${rects}${wires}</svg>`;
}

/*** iPhone tray: 10 fixed cards (2Ã—5)
     - tap: select; if already selected => rotate 90Â°
     - long-press: cycle side A -> B -> blank (if allowed)
***/
function renderTray(){
  trayEl.innerHTML = "";
  for(let pid=1; pid<=10; pid++){
    const ui = pieceUI[pid];
    const used = placements.has(pid);

    const card = document.createElement("div");
    card.className = "pieceCard" + (used ? " used":"") + (pid===selectedPid ? " selected":"");
    card.dataset.pid = String(pid);
    card.style.position = "relative";

    const lab = document.createElement("div");
    lab.className = "pLabel";
    lab.textContent = "P" + pid;
    card.appendChild(lab);

    const grid = document.createElement("div");
    grid.className = "thumbGrid";
    const modes = blankAllowed(pid) ? ["A","B","blank"] : ["A","B"];
    grid.style.gridTemplateColumns = `repeat(${modes.length}, 1fr)`;

    for(const mode of modes){
      const item = document.createElement("div");
      item.className = "thumbItem" + ((pid===selectedPid && ui.sideMode===mode) ? " sel":"");

      const box = document.createElement("div");
      box.className = "thumbSvg";
      box.innerHTML = renderThumbSvg(pid, mode, ui.rot);
      item.appendChild(box);

      item.addEventListener("click", (e)=>{
        e.preventDefault();
        e.stopPropagation();
        if(used) return;

        if(selectedPid !== pid || ui.sideMode !== mode){
          selectedPid = pid;
          ui.sideMode = mode;
          renderTray();
          setStatus(`Valittu pala ${pid}.`);
          return;
        }
        ui.rot = (ui.rot + 90) % 360;
        renderTray();
        setStatus(`Valittu pala ${pid}.`);
      });

      grid.appendChild(item);
    }

    card.appendChild(grid);
    trayEl.appendChild(card);
  }
}

/*** Placement logic ***/
function canPlace(pid, sideMode, rot, r0, c0){
  const rs = getRotatedSide(pid, sideMode, rot);

  for(const [x,y] of rs.cells){
    const r = r0 + y, c = c0 + x;
    if(r<0||c<0||r>=ROWS||c>=COLS) return false;
  }

  const occ = Array.from({length: ROWS}, ()=>Array(COLS).fill(null));
  for(const [opid, pl] of placements){
    const ors = getRotatedSide(opid, pl.sideMode, pl.rot);
    for(const [x,y] of ors.cells){
      const r = pl.r0 + y, c = pl.c0 + x;
      if(r>=0&&c>=0&&r<ROWS&&c<COLS) occ[r][c] = opid;
    }
  }
  for(const [x,y] of rs.cells){
    const r = r0 + y, c = c0 + x;
    if(occ[r][c] !== null) return false;
  }
  return true;
}

function smartPlaceAt(pid, sideMode, rot, rClick, cClick){
  const rs = getRotatedSide(pid, sideMode, rot);
  for(const [lx,ly] of rs.cells){
    const r0 = rClick - ly;
    const c0 = cClick - lx;
    if(canPlace(pid, sideMode, rot, r0, c0)){
      placements.set(pid, {pid, sideMode, rot, r0, c0});
      return true;
    }
  }
  return false;
}

function findPieceAt(r,c){
  for(const [pid, pl] of placements){
    const rs = getRotatedSide(pid, pl.sideMode, pl.rot);
    for(const [x,y] of rs.cells){
      if(pl.r0 + y === r && pl.c0 + x === c) return pid;
    }
  }
  return null;
}

function onBoardClick(e){
  const r = parseInt(e.currentTarget.dataset.r,10);
  const c = parseInt(e.currentTarget.dataset.c,10);

  const hitPid = findPieceAt(r,c);
  if(hitPid){
    if(lockedPids.has(hitPid)){
      setStatus(`Pala ${hitPid} on lukittu tÃ¤ssÃ¤ Master-pulmassa.`);
      return;
    }
    placements.delete(hitPid);
    selectedPid = hitPid;
    renderTray(); renderBoard();
    setStatus(`Poistettu pala ${hitPid}. Se on nyt valittuna.`);
    return;
  }

  const pid = selectedPid;
  if(!pid){ setStatus("Valitse pala ensin."); return; }
  if(placements.has(pid)){
    setStatus(`Pala ${pid} on jo laudalla. Poista se klikkaamalla sitÃ¤ laudalla.`);
    return;
  }

  const ui = pieceUI[pid];
  const ok = smartPlaceAt(pid, ui.sideMode, ui.rot, r, c);
  if(!ok){
    setStatus(`Palaa ${pid} ei voi asettaa tuohon (ei mahdu tai menee pÃ¤Ã¤llekkÃ¤in).`);
    return;
  }
  renderTray(); renderBoard();

  const checkRes = runFullCheckIfComplete();
  if(checkRes && placements.size === 10){
    if(checkRes.ok) setSolvedStatus(checkRes.msg);
    else setStatus(checkRes.msg);
    return;
  }
  if(placements.size !== 10){
    setStatus(`Asetettu pala ${pid} (${ui.sideMode}, ${ui.rot}Â°).`);
  }
}

/*** Wire validation ***/
function popcnt4(m){
  let n=0;
  if(m & N) n++;
  if(m & E) n++;
  if(m & S) n++;
  if(m & W) n++;
  return n;
}

function validateWires(){
  if(placements.size !== 10){
    return { ok:false, reason:`Kaikkia paloja ei ole asetettu (${placements.size}/10).` };
  }
  const { mask, pieceDot, goalDot, dotRender } = computeBoardLayers();

  let totalDots = 0;
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(pieceDot[r][c]) totalDots++;
  if(!(totalDots === 2 || totalDots === 4 || totalDots === 6)){
    return { ok:false, reason:`PisteitÃ¤ on ${totalDots}. Sallittu mÃ¤Ã¤rÃ¤ on 2, 4 tai 6.` };
  }

  if(goalDot){
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        if(goalDot[r][c] && !pieceDot[r][c]){
          return { ok:false, reason:`Tavoitepiste ruudussa (${c},${r}) ei ole palan piste (aseta pisteellinen pala siihen).` };
        }
      }
    }
  }

  const OPP = { [N]:S, [E]:W, [S]:N, [W]:E };

  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const m = mask[r][c] || 0;
      const hasDot = !!dotRender[r][c];
      if(!m){
        if(hasDot) return { ok:false, reason:`Piste ruudussa (${c},${r}) mutta ruudussa ei ole johtoa.` };
        continue;
      }
      const deg = popcnt4(m);
      if(deg >= 3) return { ok:false, reason:`Haarautuva johto ruudussa (${c},${r}) (degree ${deg}).` };
      if(hasDot && deg !== 1) return { ok:false, reason:`Piste ruudussa (${c},${r}) mutta degree on ${deg} (pisteellÃ¤ oltava 1).` };
      if(!hasDot && deg === 1) return { ok:false, reason:`Avoin johdonpÃ¤Ã¤ ruudussa (${c},${r}) ilman pistettÃ¤.` };

      for(const d of [N,E,S,W]){
        if(!(m & d)) continue;
        let rr=r, cc=c;
        if(d===N) rr--; else if(d===E) cc++; else if(d===S) rr++; else cc--;
        if(rr<0||cc<0||rr>=ROWS||cc>=COLS) return { ok:false, reason:`Johto menee ulos laudalta ruudusta (${c},${r}).` };
        const nm = mask[rr][cc] || 0;
        if(!(nm & OPP[d])) return { ok:false, reason:`Johto ei jatku: (${c},${r}) â†’ (${cc},${rr}) puuttuu vastapÃ¤Ã¤.` };
      }
    }
  }

  const seen = Array.from({length: ROWS}, ()=>Array(COLS).fill(false));
  function neighbors(r,c){
    const out=[];
    const m = mask[r][c] || 0;
    if(m & N) out.push([r-1,c]);
    if(m & E) out.push([r,c+1]);
    if(m & S) out.push([r+1,c]);
    if(m & W) out.push([r,c-1]);
    return out;
  }
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(seen[r][c]) continue;
      if(!(mask[r][c]||0)) continue;
      let stack=[[r,c]];
      seen[r][c]=true;
      let compDots=0;
      while(stack.length){
        const [rr,cc]=stack.pop();
        if(pieceDot[rr][cc]) compDots++;
        for(const [nr,nc] of neighbors(rr,cc)){
          if(nr<0||nc<0||nr>=ROWS||nc>=COLS) continue;
          if(seen[nr][nc]) continue;
          if(!(mask[nr][nc]||0)) continue;
          seen[nr][nc]=true;
          stack.push([nr,nc]);
        }
      }
      if(compDots !== 2) return { ok:false, reason:`YhdessÃ¤ johdossa on ${compDots} pistettÃ¤ (tulee olla 2).` };
    }
  }
  return { ok:true, reason:` jokainen johto alkaa ja pÃ¤Ã¤ttyy pisteeseen.` };
}

function runFullCheckIfComplete(){
  if(placements.size !== 10) return null;

  const res = validateWires();
  if(!res.ok) return { ok:false, msg: "âŒ " + res.reason };

  const lvl = String((currentPuzzle && currentPuzzle.level) || "Expert");
  if(lvl === "Expert"){
    const mg = matchesGoal();
    if(mg.ok) return { ok:true, msg: "âœ… Ratkaistu! " + mg.reason };
    return { ok:false, msg: "âŒ " + mg.reason };
  }
  return { ok:true, msg: "âœ… Johdotus ok: " + res.reason };
}

/*** Goal handling ***/
function goalToLayers(goal){
  const mask = goal.maskHex.map(row => row.split("").map(ch => parseInt(ch,16)||0));
  const dot  = Array.from({length: ROWS}, ()=>Array(COLS).fill(false));
  const dots = Array.isArray(goal.dots) ? goal.dots : [];
  for(const d of dots){
    const rr = Array.isArray(d) ? d[0] : null;
    const cc = Array.isArray(d) ? d[1] : null;
    if(rr==null || cc==null) continue;
    if(rr>=0&&cc>=0&&rr<ROWS&&cc<COLS) dot[rr][cc] = true;
  }
  return {mask, dot};
}

function matchesGoal(){
  if(!goalMask || !goalDot) return {ok:false, reason:"Tavoitetta ei ole."};
  const {mask, dotCheck: dot} = computeBoardLayers();
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if((mask[r][c]||0) !== (goalMask[r][c]||0)) return {ok:false, reason:`Johtokuva ei tÃ¤smÃ¤Ã¤ ruudussa (${c},${r}).`};
      if(!!dot[r][c] !== !!goalDot[r][c]) return {ok:false, reason:`Pisteet eivÃ¤t tÃ¤smÃ¤Ã¤ ruudussa (${c},${r}).`};
    }
  }
  return {ok:true, reason:"Tavoite tÃ¤smÃ¤Ã¤."};
}

/*** Puzzle loading + navigation (iPhone-only UI) ***/
const LS_LAST = "iqc_last_puzzle_index_v1";
const puzzleSelect = document.getElementById("puzzleSelect");
const nextBtn = document.getElementById("nextBtn");
const resetBtn = document.getElementById("resetBtn");

function resetForNewPuzzle(){
  placements.clear();
  lockedPids.clear();
  selectedPid = 1;
  for(let pid=1; pid<=10; pid++) pieceUI[pid] = { sideMode:"A", rot:0 };
}

function placeGiven(entry, lockIt){
  const pid = entry.pid;
  if(pid==null) return;
  const sideMode = entry.sideMode || entry.side || "A";
  const rot = entry.rot || 0;
  const r0 = entry.r0;
  const c0 = entry.c0;
  placements.set(pid, { pid, sideMode, rot, r0, c0 });
  if(lockIt) lockedPids.add(pid);
  pieceUI[pid].sideMode = sideMode;
  pieceUI[pid].rot = rot;
}

function loadPuzzleIndex(idx){
  idx = Number(idx);
  if(!(idx>=0 && idx<gamePuzzles.length)) return;
  currentPuzzleIndex = idx;
  currentPuzzle = gamePuzzles[idx];

  resetForNewPuzzle();

  const lvl = String(currentPuzzle.level || "Expert");
  showGoal = (lvl === "Expert");
  goalMask = null; goalDot = null;
  wizardGoalDot = null;

  if(showGoal && currentPuzzle.goal && currentPuzzle.goal.maskHex){
    const g = goalToLayers(currentPuzzle.goal);
    goalMask = g.mask;
    goalDot = g.dot;
  }

  if((lvl === "Wizard" || lvl === "Master") && currentPuzzle.goal && Array.isArray(currentPuzzle.goal.dots)){
    const d = Array.from({length: ROWS}, ()=>Array(COLS).fill(false));
    for(const p of currentPuzzle.goal.dots){
      if(!Array.isArray(p) || p.length<2) continue;
      const rr = Number(p[0]);
      const cc = Number(p[1]);
      if(rr>=0 && cc>=0 && rr<ROWS && cc<COLS) d[rr][cc] = true;
    }
    wizardGoalDot = d;
  }

  if(lvl === "Master"){
    const givens = Array.isArray(currentPuzzle.givens) ? currentPuzzle.givens : [];
    for(const e of givens) placeGiven(e, true);
  }

  renderTray();
  renderBoard();

  const num = (currentPuzzle.number!=null) ? currentPuzzle.number : "";
  setStatus(`${lvl} ${num} ladattu.`);
}

async function loadPuzzlesAuto(){
  try{
    const res = await fetch("iqc_puzzles.json", {cache:"no-store"});
    if(!res.ok) throw new Error("HTTP " + res.status);
    const json = await res.json();
    if(Array.isArray(json)) gamePuzzles = json;
    else if(json && Array.isArray(json.puzzles)) gamePuzzles = json.puzzles;
    else gamePuzzles = [];
  }catch(e){
    puzzleSelect.innerHTML = '<option value="">(pulmia ei saatu ladattua)</option>';
    setStatus("Pulmatiedostoa iqc_puzzles.json ei saatu ladattua.");
    return;
  }

  puzzleSelect.innerHTML = "";
  gamePuzzles.forEach((p,i)=>{
    const opt = document.createElement("option");
    const lvl = p.level || "";
    const num = (p.number!=null) ? p.number : "";
    opt.value = String(i);
    opt.textContent = `${lvl} ${num}`.trim() + (p.id ? ` â€¢ ${p.id}` : "");
    puzzleSelect.appendChild(opt);
  });

  if(!gamePuzzles.length){
    puzzleSelect.innerHTML = '<option value="">(ei pulmia)</option>';
    setStatus("Pulmia ei lÃ¶ytynyt tiedostosta.");
    return;
  }

  let idx = parseInt(localStorage.getItem(LS_LAST) || "0", 10);
  if(!Number.isFinite(idx) || idx < 0 || idx >= gamePuzzles.length) idx = 0;

  puzzleSelect.value = String(idx);
  loadPuzzleIndex(idx);

  puzzleSelect.addEventListener("change", ()=>{
    const v = parseInt(puzzleSelect.value, 10);
    if(!Number.isFinite(v)) return;
    localStorage.setItem(LS_LAST, String(v));
    loadPuzzleIndex(v);
  });
}

async function registerSW(){
  if(!("serviceWorker" in navigator)) return;
  try{
    await navigator.serviceWorker.register("./service-worker.js", { scope:"./" });
  }catch(e){
    console.warn(e);
  }
}

/*** iPhone controls:
     - Next button
     - Reset short tap: reset current puzzle
     - Reset long-press (520ms): clear only player's pieces (keep Master givens)
     - Status double-tap: check (validate + goal)
***/
function nextPuzzle(){
  if(!gamePuzzles.length) return;
  if(currentPuzzleIndex < gamePuzzles.length-1){
    const idx = currentPuzzleIndex + 1;
    puzzleSelect.value = String(idx);
    localStorage.setItem(LS_LAST, String(idx));
    loadPuzzleIndex(idx);
  }
}
function resetPuzzle(){
  if(currentPuzzle) loadPuzzleIndex(currentPuzzleIndex);
}
function clearPlayerPieces(){
  // Clear everything, then re-place givens if Master
  placements.clear();
  if(currentPuzzle && String(currentPuzzle.level||"") === "Master"){
    lockedPids.clear();
    const givens = Array.isArray(currentPuzzle.givens) ? currentPuzzle.givens : [];
    for(const e of givens) placeGiven(e, true);
    renderTray(); renderBoard();
    setStatus("Tyhjennetty (Master): vain pelaajan palat poistettu.");
    return;
  }
  lockedPids.clear();
  renderTray(); renderBoard();
  setStatus("Lauta tyhjennetty.");
}
function checkNow(){
  const res = validateWires();
  if(!res.ok){ setStatus("âŒ " + res.reason); return; }
  const lvl = String((currentPuzzle && currentPuzzle.level) || "Expert");
  if(lvl === "Expert"){
    const mg = matchesGoal();
    if(mg.ok) setSolvedStatus("âœ… Ratkaistu! " + mg.reason);
    else setStatus("âŒ " + mg.reason);
  }else{
    setStatus("âœ… Johdotus ok: " + res.reason);
  }
}

function wireControls(){
  nextBtn.addEventListener("click", nextPuzzle);

  // Reset: short = reset puzzle, long = clear
  let lpTimer = null;
  let didLong = false;

  const startLP = ()=>{
    didLong = false;
    clearTimeout(lpTimer);
    lpTimer = setTimeout(()=>{
      didLong = true;
      clearPlayerPieces();
    }, 520);
  };
  const cancelLP = ()=>{ clearTimeout(lpTimer); lpTimer=null; };

  resetBtn.addEventListener("pointerdown", startLP);
  resetBtn.addEventListener("pointerup", ()=>{ cancelLP(); if(!didLong) resetPuzzle(); });
  resetBtn.addEventListener("pointercancel", cancelLP);
  resetBtn.addEventListener("pointerleave", cancelLP);

  // Status double-tap => check
  let lastTap = 0;
  statusEl.addEventListener("click", ()=>{
    const t = Date.now();
    if(t - lastTap < 360){
      checkNow();
      lastTap = 0;
    }else{
      lastTap = t;
    }
  });

  // prevent iOS double-tap zoom gesture
  document.addEventListener("gesturestart", (e)=> e.preventDefault(), {passive:false});
}

/*** Boot ***/
buildBoard();
renderTray();
renderBoard();
loadPuzzlesAuto();
registerSW();
wireControls();
setStatus(`Valittu pala ${selectedPid}. Klikkaa pelialuetta asettaaksesi.`);
</script>
</body>
</html>
